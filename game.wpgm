import juego.*
import controlador.*
import wollok.game.*

program tetrizado {
    game.title("TETRIZADO")
    game.height(20)
    game.width(47)
    game.ground("celdaFondo.jpg") //imagen para cada celda
    game.cellSize(40) //tamaño de cada celda en pixeles que coincide con el tamaño de las piezas (hecho a ojo)

    var ticksCaida = 500 //milisiegundos cada los que las piezas descienden una posicion en el tablero
    var bloqueActual = controlador.generarBloqueAleatorio()
    var bloqueNext = controlador.generarBloqueAleatorio()
    var bloqueHold
    var bloqueSombra
    var contadorHolds = 0

    visuales.agregarVisuales()

    bloqueActual.entrarEnTablero()
    bloqueSombra = bloqueActual.crearSombra()
    bloqueSombra.descender()
    bloqueSombra.mostrar()
    bloqueActual.mostrar()
    bloqueNext.mostrar()

    game.start()
/*
    keyboard.z().onPressDo({
        bloqueActual.rotar("izquierda")
        bloqueSombra.imitarPos(bloqueActual)
    })
 */
    keyboard.up().onPressDo({
        bloqueActual.rotar("derecha")
        bloqueSombra.imitarPos(bloqueActual)
    })

    keyboard.left().onPressDo({
        bloqueActual.mover(izquierda)
        bloqueSombra.imitarPos(bloqueActual)
    })

    keyboard.right().onPressDo({
        bloqueActual.mover(derecha)
        bloqueSombra.imitarPos(bloqueActual)
    })

    keyboard.down().onPressDo({
        bloqueActual.mover(abajo)
    })

    keyboard.space().onPressDo({
        puntaje.sumar((bloqueActual.yCentro()*2).truncate(0))
        const retorno = bloqueActual.hardDrop()
        if (retorno == 0){
            bloqueActual = bloqueNext
            contadorHolds = 0
            bloqueActual.entrarEnTablero()
            bloqueNext = controlador.generarBloqueAleatorio()
            bloqueNext.mostrar()
            bloqueSombra.eliminar()
            bloqueSombra = bloqueActual.crearSombra()
            bloqueSombra.descender()
            bloqueSombra.mostrar()

            //esto es para que la sombra no quede por encima del bloqueActual cuando se superpongan
                bloqueActual.remover()
                bloqueActual.mostrar()
        }
    })
    
    keyboard.c().onPressDo({
        if(contadorHolds == 0){
            contadorHolds += 1
            if(bloqueHold == null){
                bloqueHold = bloqueActual
                bloqueHold.entrarEnHold()
                bloqueActual = bloqueNext
                bloqueActual.entrarEnTablero()
                bloqueNext = controlador.generarBloqueAleatorio()
                bloqueNext.mostrar()
                bloqueSombra.eliminar()
                bloqueSombra = bloqueActual.crearSombra()
                bloqueSombra.descender()
                bloqueSombra.mostrar()
            }else{
                var bloqueAux
                bloqueAux = bloqueHold
                bloqueHold = bloqueActual
                bloqueActual = bloqueAux
                bloqueHold.entrarEnHold()
                bloqueActual.entrarEnTablero()
                bloqueSombra.eliminar()
                bloqueSombra = bloqueActual.crearSombra()
                bloqueSombra.descender()
                bloqueSombra.mostrar()
            }

            //esto es para que la sombra no quede por encima del bloqueActual cuando se superpongan
                bloqueActual.remover()
                bloqueActual.mostrar()

        }
    })
    
    game.onTick(ticksCaida, "Caida", 
    {
        bloqueActual.caer()

        if(bloqueActual.estaEnElFondo()){
            game.schedule(500, { //La idea de esto es que tengas un ratito para mover la pieza antes de que se quede fija
                if (bloqueActual.estaEnElFondo()){
                    bloqueActual.establecerEnTablero()
                    bloqueActual = bloqueNext
                    contadorHolds = 0
                    bloqueActual.entrarEnTablero()
                    bloqueNext = controlador.generarBloqueAleatorio()
                    bloqueNext.mostrar()
                    bloqueSombra.eliminar()
                    bloqueSombra = bloqueActual.crearSombra()
                    bloqueSombra.descender()
                    bloqueSombra.mostrar()

                    //esto es para que la sombra no quede por encima del bloqueActual cuando se superpongan
                    bloqueActual.remover()
                    bloqueActual.mostrar()
                }
            })
        }
    })
    
    //cada 1 minuto (60 segundos) se reduce el tiempo de caida
    game.onTick(1000*60 , "Incremento de Dificultad", {
        if(ticksCaida > 50){
            ticksCaida -= 50
            nivel.sumar(1)
        } else {
            game.removeTickEvent("Incremento de Dificultad")
        }
    })
    /*
       No pareciera acelerarse la velocidad de caida de las piezas...
       Quizas porque hay muchas acciones que se hacen cada vez que la pieza cae y 
       hasta que no se hacen todas no se vuelve a ejecutar el evento de caida
    */

}
